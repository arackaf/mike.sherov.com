<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Mike Sherov]]></title><description><![CDATA[Mike Sherov's personal website and blog]]></description><link>http://mike.sherov.com/</link><generator>RSS for Node</generator><lastBuildDate>Mon, 08 Jul 2019 02:17:05 GMT</lastBuildDate><item><title><![CDATA[Response to “Enabling Modern JavaScript on npm”]]></title><description><![CDATA[The Problem In a recent blog post, Jason Miller lays out a problem: given that the average JS application is composed of >50% 3rd party…]]></description><link>http://mike.sherov.com//enabling-modern-javascript/</link><guid isPermaLink="false">http://mike.sherov.com//enabling-modern-javascript/</guid><pubDate>Tue, 04 Jun 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;The Problem&lt;/h2&gt;
&lt;p&gt;In &lt;a href=&quot;https://jasonformat.com/enabling-modern-js-on-npm/&quot;&gt;a recent blog post&lt;/a&gt;, Jason Miller lays out a problem:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;given that the average JS application is composed of &gt;50% 3rd party JavaScript,&lt;/li&gt;
&lt;li&gt;And given that 3rd party code (which we’ll call library code) on npm still typically targets ES5 because it’s still the lowest common denominator,&lt;/li&gt;
&lt;li&gt;And given that ES6 is more expressive and has a larger set of builtin functionality so it results in much smaller code than ES5,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;That the average application, even if the first party code (which we’ll call application code) is ES6 and not transpiled to ES5, is much larger than it needs to be!&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;The Solution Landscape&lt;/h2&gt;
&lt;p&gt;Central to any solution here is the notion that library authors must feel free to publish ES6+ as the new lowest common denominator. Yes, it’s important to solve differential building across any version of JS, but I would specifically call out the ES5 - ES6 cliff as uniquely important because ES5 is the “Nevergreen Cliff”. That is, the last browser that isn’t Evergreen is IE11, and it doesn’t support ES6. All other version disparities will play out on shorter timescales with likely less urgency. Even still, a generic solve for any version of JS is important here. There will always be more cliffs.&lt;/p&gt;
&lt;p&gt;We must also identify the players here:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Application developers, who need good tooling defaults so that they get small application bundles that still match their browser support statements.&lt;/li&gt;
&lt;li&gt;Library authors, who need a reasonable guarantee from tooling authors that tooling will make it essentially effort-free for app devs to consume ES6, lest they get blowback and support burden from app devs who still need ES5.&lt;/li&gt;
&lt;li&gt;Compiler authors, specifically Babel, Buble, TS, who need to know that if they can make it effort free for devs to consume es6, that the library authors will agree to actually publish ES6 as the main npm artifact of the library.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Solution Part 1 - Transforming node_modules&lt;/h2&gt;
&lt;p&gt;The crux of the problem is that the current class of compilers (we’ll use Babel as the example considering its prominence) don’t touch node&lt;em&gt;modules by default. Unless you explicitly tell Babel to, it won’t compile your node&lt;em&gt;modules. There’s good reason for this. 3rd party node&lt;/em&gt;modules are all already valid es5, so running the compiler on them are effectively no-ops, and it slows your build to attempt to compile something that doesn’t need it! Also, because Babel isn’t just a JS to JS compiler and it in fact has a rich plugin ecosystem and you may be using experimental proposals in your code or React transforms in your code, running those transforms over node&lt;em&gt;modules doesn’t make sense \&lt;/em&gt;either&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;With this understanding, let’s take a step back now and imagine what we’d &lt;em&gt;want&lt;/em&gt; Babel to do to enable the ecosystem to move onto es6:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Allow an app dev to specify target environment (available today as babel-preset-env). That is, an app should be able to say “no matter what version of JS all my code + dependencies are, I want to transform that to whatever version of JS is the lowest common denominator of these browsers / environments”.&lt;/li&gt;
&lt;li&gt;Allow an app dev to specify other transforms to run on 1st party (or 2nd party) code. That is, in addition to saying what version of JS the output should be, the app dev should be able to say “my 1st party code is
actually JSX, and also, these specific packages in node_modules I rely upon are actually TS”, etc.&lt;/li&gt;
&lt;li&gt;Take all known stage 4 transforms (that is, all transforms that cam turn any ES6+ code to ES5), remove the transforms are not required by your target environment, and run those over all node_modules that aren’t already handled by step 2 above.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This would means that library authors who are using TS or Flow or JSX still have to transpile to JS, but not necessarily ES5! The library author becomes free to publish ES6 on the knowledge that prevalent tooling will downlevel their JS to the correct target.&lt;/p&gt;
&lt;p&gt;Now, from a correctness perspective, I think this’d work, but how do we address build performance issues? As mentioned above, suddenly compiling all node_modules will definitely slow down builds. If library authors were willing to publish a machine readable file announcing what version of JS they are, similar to the “engines” field of package.json, Babel would be able to bail out of transpiling if it could determine that the library is a version of JS that is less than or equal to the version required by the application. In fact, Babel could theoretically produce this file. It could have a mode where instead of actually transpiling to es5, it just notes what transforms would not be no-ops and write those to a file, to be consumed by a future run of Babel later. For simplicity’s sake though, perhaps it’s simpler to write “ES2019” than “polyfill Array.flat, and run all ES2018 transforms, and…” This file would also help detect if the JS version of the library is a version that your version of Babel doesn’t yet transpile, and can warn the application dev to upgrade.&lt;/p&gt;
&lt;h2&gt;Solution Part 2 - ES6 Readiness Day&lt;/h2&gt;
&lt;p&gt;With Babel and the other compilers now behaving as described, we’d set our sights to library authors. How do we get them to stop shipping ES5, now that the compilers can help out here?&lt;/p&gt;
&lt;p&gt;While we may think of npm as a vast sprawling treasure trove of dependencies at our fingertips, in reality, there are some &lt;em&gt;really really&lt;/em&gt; common dependencies out there that make up a huge percent of what gets shipped to browsers these days: &lt;a href=&quot;https://www.npmjs.com/browse/depende&quot;&gt;https://www.npmjs.com/browse/depende&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If we could convince the top most depended on packages to switch, couldn’t we say we achieved the mission?&lt;/p&gt;
&lt;p&gt;Thankfully, there is prior art… “Can I Use Python 3?” This is what happened with Python 3. Python 3 was a huge jump from Python 2, and for years the community was frozen on Py2 because very popular packages weren’t shipping Py3 yet. The community eventually banded together and began publishing websites that simply listed the top Python packages and whether they yet supported Py3: &lt;a href=&quot;http://py3readiness.org/&quot;&gt;http://py3readiness.org/&lt;/a&gt; &lt;a href=&quot;https://python3wos.appspot.com/&quot;&gt;https://python3wos.appspot.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Perhaps as a community, we could do similar… armed with buy in from the compiler ecosystem and a single request “please ship es6 instead of ES5, and the compilers will downlevel for you if necessary”, we throw up a site that tracks progress towards this goal for the top 500 npm packages. We set a date to shoot for. We declare Jan 1st 2020 (or some more reasonable date) as the date to strive for 50% (or some more reasonable percent). Of course, you can probably just get a commitment from the top 20 and a handful of profilic publishers and that’d be a huge head start :-)&lt;/p&gt;
&lt;h2&gt;Putting it All Together&lt;/h2&gt;
&lt;p&gt;In summary, if we first made sure compilers could transform any version of actual JS in node_modules (stage 4 syntax w no custom transforms) to the version required by the app dev, it unblocks library author’s ability to now publish in es6 without making app devs jump through configuration hoops to get a dependency. If we also provide a common format for libraries to declare the version of JS they are, we can overcome build speed issues. With that unblocked, we socialize the goal and get public commitments from top lib authors to move to es6 on an aspirational timeframe. Hopefully one day soon, downleveling to ES5 will seem as unnecessary as downleveling to ES3!&lt;/p&gt;
&lt;p&gt;It would involve getting broad support from compilers (not just Babel, but also pika, Buble, Typescript, And others, along with maybe installers like Yarn or npm), and top package authors, and community advocates to band together. It wouldn’t be easy, but if we got agreement, it would work.&lt;/p&gt;
&lt;p&gt;Of course, there is some nuance missing in the descriptions above, but as an overall strategy, this seems like a clear way to move the ball forward that isn’t “just wait for IE11 to die.” Because even then, with the ES5 cliff behind us, there will always be future cliffs, even if they are less severe.&lt;/p&gt;
&lt;p&gt;Thoughts?&lt;/p&gt;</content:encoded></item><item><title><![CDATA[In Defense of the 10x Developer]]></title><description><![CDATA[One of the most persistent software development memes is making fun of recruiter-speak. You know, the type of language used by the clueless…]]></description><link>http://mike.sherov.com//10x-developer/</link><guid isPermaLink="false">http://mike.sherov.com//10x-developer/</guid><pubDate>Thu, 10 Dec 2015 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;One of the most persistent software development memes is making fun of recruiter-speak. You know, the type of language used by the clueless recruiter trying to communicate a challenging role. “This company is looking to hire a real ninja.” Or “rock star developer”. Or “10x developer”. It’s obvious to me that both “ninja” and “rock star” are embarrassingly aggressive and brogrammy terms to apply to the craft of software development, but “10x” seems like it’s worthy of a second look.&lt;/p&gt;
&lt;h2&gt;10x the Features?&lt;/h2&gt;
&lt;p&gt;At its roots, those who ridicule the concept of a 10x developer are interpreting 10x to mean 10x the amount of features or code. “Yeah, right, 10x! More like 10x the technical debt”. Seems like that joke at its heart is an insult to both the developer who thinks their only measure is their code output, and whoever that poor sap’s manager is, who’s actively using LOC or feature output as the only measure of success. That’s &lt;em&gt;not&lt;/em&gt; what I’m defending. If you work somewhere where your only measure is feature output, quit yesterday. By all means. For the rest of us who have competent managers who view us holistically…&lt;/p&gt;
&lt;h2&gt;10x the Impact?&lt;/h2&gt;
&lt;p&gt;Another common attempt at deriding the 10x developer concept goes like this: “Really, it just happens to be that senior staff get chosen to work on more important stuff than juniors, and therefore, 10x devs don’t exist as much as 10x projects do”. This is certainly true, at least to some level at all companies. However, again, if you work in an org where there isn’t enough important work for everyone, and only the senior team can do the work, quit two days ago. &lt;strong&gt;The codebase should be well tested so you can practice collective ownership&lt;/strong&gt; and business should get its priorities straight so that there aren’t wild discrepancies in importance for everyone.&lt;/p&gt;
&lt;h2&gt;10x the What?&lt;/h2&gt;
&lt;p&gt;If I’m not talking about LOC (or any other braindead metric for measuring software “output”), and I’m not talking impact, then 10x what? What is the 10x developer 10x better at than her colleagues? Quite simply: raising the effectiveness of those who sit around her. &lt;strong&gt;A true 10x developer helps her teammates accomplish their goals.&lt;/strong&gt; A 10x developer takes the time to communicate challenges and solutions she encountered during the day so that her teammates may learn something new. A 10x dev gives thorough code reviews, talks face to face with the submitter of each PR to discuss best practices. A 10x dev makes tools the rest of the team uses. The joke I’ve heard to describe the 10x dev goes like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To be a 10x dev, make 5 2x devs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you are a 10x dev, it’s on you to make sure you’re working somewhere that can see it, nurture it, and get you on the road to being a 100x dev.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;If you measure yourself, or worse, if your boss measures you by features built or LOC, quit.&lt;/p&gt;
&lt;p&gt;If the seniors get all the glory because they’re the only heroes who get to work on high impact stuff, quit.&lt;/p&gt;
&lt;p&gt;If you’re surrounded by 2x developers, chances are you’re a 10x developer. Make sure you work somewhere that recognizes that.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Shipping is Your Primary Feature]]></title><description><![CDATA[I’ll keep this one short and sweet, and just say this: The most important feature that your software can have is that it’s in the hands of…]]></description><link>http://mike.sherov.com//shipping-is-your-primary-feature/</link><guid isPermaLink="false">http://mike.sherov.com//shipping-is-your-primary-feature/</guid><pubDate>Wed, 01 May 2013 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;I’ll keep this one short and sweet, and just say this: The most important feature that your software can have is that it’s in the hands of end users. That’s where features are truly fleshed out through actual use.&lt;/p&gt;
&lt;p&gt;Although I disagree with some of the points in the article, I can’t say it any better than Jamie Zawinski as quoted by Joel Spolsky in &lt;a href=&quot;http://www.joelonsoftware.com/items/2009/09/23.html&quot;&gt;The Duct Tape Programmer&lt;/a&gt; (interesting article, about 5 minutes to read): “&lt;strong&gt;But that’s not the point — you’re not here to write code; you’re here to ship products.&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;Oh, and here’s a great quote from this Wikipedia on
&lt;a href=&quot;http://en.wikipedia.org/wiki/Salted_duck_egg&quot;&gt;salted duck eggs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Idea for the day: remember &lt;a href=&quot;http://en.wikipedia.org/wiki/You_ain%27t_gonna_need_it&quot;&gt;YAGNI&lt;/a&gt; (You Ain’t Gonna Need It)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Writing Clear Code, Not Clever Code]]></title><description><![CDATA[In Practices of an Agile Developer, Andy Hunt and Venkat Subramaniam outline a huge list of ways to improve yourself as a software developer…]]></description><link>http://mike.sherov.com//clear-code/</link><guid isPermaLink="false">http://mike.sherov.com//clear-code/</guid><pubDate>Sun, 15 Apr 2012 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;In &lt;a href=&quot;http://www.amazon.com/gp/product/097451408X&quot;&gt;Practices of an Agile Developer&lt;/a&gt;, Andy Hunt and Venkat Subramaniam outline a huge list of ways to improve yourself as a software developer. While I found almost every tip in the book to be useful, I found one tip to stand out from the rest, considering it pointed out one of my particularly bad habits: “Write clear code, not clever code”.&lt;/p&gt;
&lt;p&gt;One of my passions as a programmer is figuring out new and better ways to do the same thing. I love refactoring code and finding out what was being done in 10 lines, I could do in 3. Or as a better measure, doing something with one if else block instead of a triply nested if else statement. Usually this works out great. The code is simpler to maintain, and less complex for all involved.&lt;/p&gt;
&lt;p&gt;However, in my endless pursuit of smaller, clearer code, I would often end up with smaller, more confusing code. In 2009, as a member of a 7 person agile team, it was very easy to measure how I was doing in this category: How often did another team member ask me what a piece of code did? Once I began looking at these problematic blocks of code, I noticed a pattern, and began to work on resolving the problem. It doesn’t matter what my particular problem was… what mattered was that I began looking for it!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pay attention to your team members.&lt;/strong&gt; Look into why they’re asking you about your code. Maybe there is something you do that makes perfect sense to you, but could be written clearer. &lt;strong&gt;Consider the next person who’s going to be looking at your code.&lt;/strong&gt; Chances are, they’ll be happier looking at clearer code, not clever code. You’ll be happier too.&lt;/p&gt;</content:encoded></item></channel></rss>